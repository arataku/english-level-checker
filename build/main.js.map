{
  "version": 3,
  "sources": ["../src/resultDisplay/statusText.ts", "../src/resultDisplay/index.ts", "../src/dict.ts", "../src/main.ts"],
  "sourcesContent": ["export class StatusText {\n  constructor(public text: HTMLParagraphElement) {}\n\n  startTime: number | null = null;\n  wordCount: number = 0;\n  timeout: number[] = [];\n\n  private set content(v: string) {\n    this.text.textContent = v;\n  }\n\n  start() {\n    this.startTime = new Date().getTime();\n    const t = window.setTimeout(() => {\n      this.content = \"Scanning...\";\n      this.timeout = this.timeout.filter((v) => v !== t);\n    }, 300);\n    this.timeout.push(t);\n  }\n\n  finishScan(wordCount: number) {\n    const t = window.setTimeout(() => {\n      this.wordCount = wordCount;\n      this.content = `0/${this.wordCount} Words...`;\n      this.timeout = this.timeout.filter((v) => v !== t);\n    }, 300);\n    this.timeout.push(t);\n  }\n\n  processedWordCountRefresh(processed: number) {\n    if (this.startTime === null) return;\n    if (new Date().getTime() - this.startTime < 300) return;\n    this.content = `${processed}/${this.wordCount} Words...`;\n  }\n\n  finish(wordCount: number) {\n    this.timeout = this.timeout.filter((v) => {\n      clearInterval(v);\n      return false;\n    });\n    if (this.startTime !== null) {\n      this.content = `Ready! ${wordCount} Words (${\n        new Date().getTime() - this.startTime\n      }ms)`;\n    } else {\n      this.content = `Ready! ${wordCount} Words`;\n    }\n  }\n}\n", "import { StatusText } from \"./statusText\";\n\nexport const Colors = {\n  RED: \"red\",\n  ORANGE: \"orange\",\n  BLACK: \"black\",\n} as const;\n\nclass Cursor {\n  constructor(public text: string) {}\n}\n\ninterface ProccessorResult {\n  color: typeof Colors[keyof typeof Colors];\n  refreshedText?: string;\n}\ntype TokenProcessor = (\n  cursor: Cursor,\n  level: number\n) => ProccessorResult;\n\nexport class ResultDisplay {\n  private _textElement: HTMLTextAreaElement | undefined;\n  private _levelElement: HTMLInputElement | undefined;\n  private _displayDivElement: HTMLDivElement | undefined;\n  private _processor: TokenProcessor | undefined;\n\n  constructor() {}\n\n  textElement(element: HTMLElement | null) {\n    if (!(element instanceof HTMLTextAreaElement)) {\n      throw \"inputElement must be an instance of HTMLTextAreaElement.\";\n    }\n    this._textElement = element;\n    return this;\n  }\n\n  levelElement(element: HTMLElement | null) {\n    if (!(element instanceof HTMLInputElement)) {\n      throw \"levelElement must be an instance of HTMLInputElement.\";\n    }\n    this._levelElement = element;\n    return this;\n  }\n\n  displayDivElement(element: HTMLElement | null) {\n    if (!(element instanceof HTMLDivElement)) {\n      throw \"displayDivElement must be an instance of HTMLDivElement.\";\n    }\n    this._displayDivElement = element;\n    return this;\n  }\n\n  processor(lambda: TokenProcessor) {\n    this._processor = lambda;\n    return this;\n  }\n\n  render() {\n    if (\n      this._textElement === undefined ||\n      this._levelElement === undefined ||\n      this._displayDivElement === undefined ||\n      this._processor === undefined\n    ) {\n      throw \"render must be executed after inputElement, displayDivElement, and processor.\";\n    }\n    new RenderedResultDisplay(\n      this._textElement,\n      this._levelElement,\n      this._displayDivElement,\n      this._processor\n    );\n  }\n}\n\nconst immediate = () => new Promise((resolve) => setTimeout(resolve, 0));\n\ninterface Token {\n  beforeText: string;\n  text: string;\n  afterText: string;\n  color: typeof Colors[keyof typeof Colors];\n  refreshedText?: string | undefined,\n  elements: HTMLSpanElement[];\n}\nclass RenderedResultDisplay {\n  tokenViewer: HTMLDivElement;\n  statusText: StatusText;\n  startElement: HTMLSpanElement;\n  tokens: Token[] = [];\n\n  rendering: boolean = false;\n\n  private static splitText(t: string) {\n    const s = t.match(/^([^a-zA-Z-\\']*)([a-zA-Z-\\']+)([^a-zA-Z-\\']*)$/);\n\n    return s === null\n      ? {\n          beforeText: \"\",\n          text: t,\n          afterText: \"\",\n        }\n      : {\n          beforeText: s[1],\n          text: s[2],\n          afterText: s[3],\n        };\n  }\n\n  private static colorSpan(\n    text: string,\n    color: typeof Colors[keyof typeof Colors],\n    linebreak: boolean = false\n  ) {\n    const span = document.createElement(\"span\");\n    span.textContent = text;\n    span.classList.add(color);\n    if (linebreak) span.classList.add(\"linebreak\");\n    return span;\n  }\n\n  constructor(\n    private textElement: HTMLTextAreaElement,\n    private levelElement: HTMLInputElement,\n    private displayDivElement: HTMLDivElement,\n    private processor: TokenProcessor\n  ) {\n    const statusTextInstance = document.createElement(\"p\");\n    this.statusText = new StatusText(statusTextInstance);\n    this.tokenViewer = document.createElement(\"div\");\n    this.startElement = document.createElement(\"span\");\n\n    this.tokenViewer.appendChild(this.startElement);\n\n    displayDivElement.appendChild(statusTextInstance);\n    displayDivElement.appendChild(this.tokenViewer);\n\n    const changeDifficulty = async (parsedLevel: number) => {\n\n      if (this.rendering) {\n        console.warn(\"It is skipped because render during render.\");\n        return;\n      }\n      this.rendering = true;\n\n      this.statusText.start();\n      this.statusText.finishScan(this.tokens.length);\n\n      const needToRefreshes: {\n        index: number,\n        newToken: ProccessorResult,\n      }[] = [];\n      for(let i = 0; i < this.tokens.length; i++) {\n        const token = this.tokens[i];\n        const d = processor({ text: token.text }, parsedLevel);\n        if(d.color !== token.color || d.refreshedText !== token.refreshedText) {\n          needToRefreshes.push({\n            index: i,\n            newToken: d\n          });\n        }\n        if(i % 20 === 0) {\n          this.statusText.processedWordCountRefresh(i);\n          await immediate();\n        }\n      }\n\n      this.statusText.processedWordCountRefresh(this.tokens.length);\n      await immediate();\n\n      const toBeRemove: HTMLElement[] = [];\n      this.tokens = this.tokens.map((v, i) => {\n        const a = needToRefreshes.find(v => v.index === i)?.newToken;\n        if(a === undefined) return v;\n\n        const changeStart = i === 0 ? this.startElement : this.tokens[i - 1].elements[\n          this.tokens[i - 1].elements.length - 1\n        ];\n\n        const elements = v.text === \"\\n\"\n        ? [RenderedResultDisplay.colorSpan(\"\", \"black\", true)]\n        : [\n            RenderedResultDisplay.colorSpan(v.beforeText, \"black\"),\n            RenderedResultDisplay.colorSpan(\n              a.refreshedText ?? v.text,\n              a.color\n            ),\n            RenderedResultDisplay.colorSpan(\n              v.afterText + \" \",\n              \"black\"\n            ),\n          ];\n\n        toBeRemove.push(...v.elements);\n\n        const fragment = document.createDocumentFragment();\n        elements.forEach(v => fragment.appendChild(v));\n        changeStart.parentNode?.insertBefore(fragment, changeStart.nextSibling);\n        return {\n          beforeText: v.beforeText,\n          text: v.text,\n          afterText: v.afterText,\n          ...a,\n          elements\n        }\n      });\n      toBeRemove.forEach(v => v.remove())\n      this.statusText.finish(this.tokens.length);\n\n      await immediate();\n      const parsedLevelNewer = Math.floor(Number(this.levelElement.value));\n      if(parsedLevel !== parsedLevelNewer) {\n        this.rendering = false;\n        console.log(`Playback: ${parsedLevelNewer}`)\n        changeDifficulty(parsedLevelNewer);\n        return;\n      }\n      this.rendering = false;\n    };\n\n    const render = async () => {\n      if (this.rendering) {\n        console.warn(\"It is skipped because render during render.\");\n        return;\n      }\n      this.rendering = true;\n      this.statusText.start();\n      const value = this.textElement.value;\n      const text =\n        value === \"\"\n          ? []\n          : (value.endsWith(\" \") ? value.slice(0, -1) : value)\n              .split(/\\n/)\n              .map((v) => v.split(\" \"))\n              .flatMap((v) => [...v, \"\\n\"]);\n\n      await immediate();\n\n      const textSplitted = text.map(RenderedResultDisplay.splitText);\n\n      let needRefreshStart = 0;\n      let needRefreshEnd = 0;\n\n      for (\n        let i = 0;\n        i < Math.min(textSplitted.length, this.tokens.length);\n        i++\n      ) {\n        const targetSplitted = textSplitted[i];\n        const tokenSplitted = this.tokens[i];\n        if (\n          targetSplitted.text === tokenSplitted.text &&\n          targetSplitted.beforeText === tokenSplitted.beforeText &&\n          targetSplitted.afterText === tokenSplitted.afterText\n        ) {\n          needRefreshStart++;\n        } else {\n          break;\n        }\n      }\n\n      await immediate();\n\n      for (\n        let i = 0;\n        i < Math.min(textSplitted.length, this.tokens.length);\n        i++\n      ) {\n        const targetSplitted = textSplitted[textSplitted.length - i - 1];\n        const tokenSplitted = this.tokens[this.tokens.length - i - 1];\n\n        if (\n          targetSplitted.text === tokenSplitted.text &&\n          targetSplitted.beforeText === tokenSplitted.beforeText &&\n          targetSplitted.afterText === tokenSplitted.afterText\n        ) {\n          needRefreshEnd++;\n        } else {\n          break;\n        }\n      }\n\n      await immediate();\n\n      const beginElement =\n        needRefreshStart === 0\n          ? this.startElement\n          : this.tokens[needRefreshStart - 1].elements[\n              this.tokens[needRefreshStart - 1].elements.length - 1\n            ];\n\n      const fragment = document.createDocumentFragment();\n      const generatedTokens: Token[] = [];\n\n      this.statusText.finishScan(\n        textSplitted.length - needRefreshEnd - 1 - needRefreshStart\n      );\n\n      const parsedLevel = Math.floor(Number(this.levelElement.value));\n      for (\n        let i = needRefreshStart;\n        i <= textSplitted.length - needRefreshEnd - 1;\n        i++\n      ) {\n        const splitted = textSplitted[i];\n        const d = processor(\n          { text: splitted.text },\n          parsedLevel,\n        );\n        const elements =\n          splitted.text === \"\\n\"\n            ? [RenderedResultDisplay.colorSpan(\"\", \"black\", true)]\n            : [\n                RenderedResultDisplay.colorSpan(splitted.beforeText, \"black\"),\n                RenderedResultDisplay.colorSpan(\n                  d.refreshedText ?? splitted.text,\n                  d.color\n                ),\n                RenderedResultDisplay.colorSpan(\n                  splitted.afterText + \" \",\n                  \"black\"\n                ),\n              ];\n        generatedTokens.push({\n          ...splitted,\n          ...d,\n          elements,\n        });\n        elements.forEach((v) => fragment.appendChild(v));\n        if((i - needRefreshStart + 1) % 20 === 0) {\n          this.statusText.processedWordCountRefresh(i - needRefreshStart + 1);\n          await immediate();\n        }\n      }\n\n      beginElement.parentNode?.insertBefore(fragment, beginElement.nextSibling);\n\n      const toDelete = this.tokens\n        .filter(\n          (_, i) =>\n            needRefreshStart <= i &&\n            i <= this.tokens.length - needRefreshEnd - 1\n        )\n        .flatMap((v) => v.elements);\n\n      console.log(toDelete);\n\n      toDelete.forEach((v) => v.remove());\n\n      if (this.tokens.length === 0) {\n        this.tokens = generatedTokens;\n      } else {\n        this.tokens = this.tokens.flatMap((v, i) => {\n          if (i === 0 && needRefreshStart === 0) {\n            return generatedTokens;\n          }\n          if (i === needRefreshStart - 1) {\n            return [v, ...generatedTokens];\n          }\n          if (\n            needRefreshStart <= i &&\n            i <= this.tokens.length - needRefreshEnd - 1\n          ) {\n            return [];\n          } else {\n            return [v];\n          }\n        });\n      }\n      this.statusText.finish(this.tokens.length);\n      /*\n      console.log({\n        textSplitted,\n        tokens: this.tokens,\n        needRefreshStart,\n        needRefreshEnd,\n        beginElement\n      });\n      */\n      this.rendering = false;\n    };\n\n    this.textElement.addEventListener(\"input\", () => render());\n\n    const levelRefresh = () => {\n      const parsedLevel = Math.floor(Number(this.levelElement.value));\n      let valueElement = document.getElementById(\n        \"range_value\"\n      ) as HTMLSpanElement;\n      valueElement.textContent = parsedLevel.toString();\n\n      changeDifficulty(parsedLevel);\n    }\n\n    this.levelElement.addEventListener(\"input\", () => levelRefresh());\n    this.levelElement.addEventListener(\"change\", () => levelRefresh());\n  }\n}\n", "export class Search {\r\n  private cache: { english: string[]; japanese: string[]; idx: number[] } = {\r\n    english: [],\r\n    japanese: [],\r\n    idx: [],\r\n  };\r\n  dict:\r\n    | { english: [string[], string[], string[], string[]]; japanese: string[] }\r\n    | undefined = undefined;\r\n  constructor() {}\r\n  readtxt(txt: string, englishCol: number, japaneseCol: number) {\r\n    this.cacheClear();\r\n    let tmpDict: {\r\n      english: [string[], string[], string[], string[]];\r\n      japanese: string[];\r\n    } = {\r\n      english: [[], [], [], []],\r\n      japanese: [],\r\n    };\r\n    for (const value of txt.split(\"\\n\")) {\r\n      let tmp = value.split(\"\\t\");\r\n      if (tmp.length < englishCol || tmp.length < japaneseCol) {\r\n        break;\r\n      }\r\n      tmpDict.english.map((v, idx) =>\r\n        v.push(\r\n          tmp[englishCol].toLowerCase().slice(0, tmp[englishCol].length - idx)\r\n        )\r\n      );\r\n      tmpDict.japanese.push(tmp[japaneseCol]);\r\n    }\r\n    this.dict = tmpDict;\r\n  }\r\n  searchWord(word: string, minLevel: number): string | undefined {\r\n    const tmp = this.cache.english.indexOf(word);\r\n    if (tmp !== -1 && this.cache.japanese[tmp]) {\r\n      if (minLevel <= this.cache.idx[tmp]) {\r\n        return this.cache.japanese[tmp];\r\n      } else {\r\n        return undefined;\r\n      }\r\n    }\r\n    if (this.dict === undefined) return undefined;\r\n    const safeDict = this.dict;\r\n    for (let j = 0; j < 4; j++) {\r\n      for (let i = 0; i < 4; i++) {\r\n        const tmp = word.slice(0, word.length - i).toLowerCase();\r\n        const idx = this.dict.english[j].indexOf(tmp);\r\n        if (idx !== -1) {\r\n          if (!this.cache.english.includes(word))\r\n            this.addCache(word, this.dict.japanese[idx], idx);\r\n          if (idx >= minLevel && this.dict.japanese[idx]) {\r\n            return this.dict.japanese[idx];\r\n          } else {\r\n            return undefined;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return undefined;\r\n  }\r\n  private addCache(english: string, japanese: string, idx: number) {\r\n    this.cache.english.push(english);\r\n    this.cache.japanese.push(japanese);\r\n    this.cache.idx.push(idx);\r\n    if (this.cache.english.length > 3000) {\r\n      this.cache.english.shift();\r\n      this.cache.japanese.shift();\r\n      this.cache.idx.shift();\r\n    }\r\n  }\r\n  private cacheClear() {\r\n    this.cache = {\r\n      english: [],\r\n      japanese: [],\r\n      idx: [],\r\n    };\r\n  }\r\n}\r\n", "import { Colors, ResultDisplay } from \"./resultDisplay\";\nimport { Search } from \"./dict\";\n\nnew ResultDisplay()\n  .textElement(document.getElementById(\"input\"))\n  .levelElement(document.getElementById(\"level\"))\n  .displayDivElement(document.getElementById(\"resultdisplay_main\"))\n  .processor((c, level) => {\n    if (search.dict === undefined) return { color: Colors.BLACK };\n    const tmp = search.searchWord(c.text, level);\n    //const tmp = \"hoge\";\n    if (tmp !== undefined) {\n      return { color: Colors.RED, refreshedText: `${c.text}(${tmp})` };\n    } else {\n      return { color: Colors.BLACK };\n    }\n  })\n\n  .render();\n\nconst search = new Search();\nconst txtInput = document.getElementById(\"anki_txt\");\nconst txtInputRefresh = document.getElementById(\"anki_txt_refresh\");\nconst level = document.getElementById(\"level\") as HTMLInputElement;\nconst englishCol = document.getElementById(\n  \"anki_setting_english_col\"\n) as HTMLInputElement;\nconst japaneseCol = document.getElementById(\n  \"anki_setting_japanese_col\"\n) as HTMLInputElement;\n\nif (localStorage.anki_txt_dict !== undefined) {\n  search.dict = JSON.parse(localStorage.anki_txt_dict);\n  if (search.dict) level.max = search.dict.japanese.length.toString();\n}\n\nlet file = document.getElementById(\"import_anki_txt_file\") as HTMLInputElement;\nfile.addEventListener(\"change\", () => {\n  let reader = new FileReader();\n  reader.onload = () => {\n    if (!reader.result) return;\n    search.readtxt(\n      reader.result?.toString(),\n      Number(englishCol.value),\n      Number(japaneseCol.value)\n    );\n    localStorage.anki_txt_dict = JSON.stringify(search.dict);\n    if (search?.dict) {\n      level.max = search.dict.japanese.length.toString();\n    } else {\n      level.max = \"1\";\n    }\n  };\n\n  if (!file.files) return;\n  reader.readAsText(file.files[0], \"UTF-8\");\n});\n\ntxtInputRefresh?.addEventListener(\"click\", () => {\n  if (\n    search.dict === undefined\n      ? true\n      : window.confirm(\n          \"\u3059\u3067\u306B\u4FDD\u5B58\u3055\u308C\u305F\u30C7\u30FC\u30BF\u304C\u3042\u308A\u307E\u3059\u3002\\r\u4E0A\u66F8\u304D\u3057\u3066\u66F4\u65B0\u3057\u307E\u3059\u304B\uFF1F\"\n        )\n  ) {\n    if (!(txtInput instanceof HTMLTextAreaElement)) {\n      throw \"#anki_txt does not exist or is not an instance of HTMLInputElement!\";\n    }\n    search.readtxt(txtInput.value, 2, 4);\n    if (search?.dict) {\n      level.max = search.dict.japanese.length.toString();\n    } else {\n      level.max = \"1\";\n    }\n    localStorage.anki_txt_dict = JSON.stringify(search.dict);\n    alert(\"\u30C7\u30FC\u30BF\u3092\u66F4\u65B0\u3057\u307E\u3057\u305F\u3002\");\n  }\n});\n"],
  "mappings": "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",
  "names": []
}
